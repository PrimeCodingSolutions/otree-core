{% extends "global/Page.html" %}
{% load otree static %}
{% load static %}
{% block content %}
    <h2>{{ question.title }}</h2>
    <p>{{ question.text }}</p>
    <p>{{ question.preference }}</p>
    <p>{{ question.challenge }}</p>

    <style>
        .flash {
            animation-name: flash;
            animation-duration: 0.2s;
            animation-timing-function: linear;
            animation-iteration-count: infinite;
            animation-direction: alternate;
            animation-play-state: running;
        }

        @keyframes flash {
            from {
                color: red;
            }
            to {
                color: black;
            }
        }
    </style>



    <div style="display: flex; flex-direction: column; position: relative; min-height: 300px" class="answer-container"
         id="d3container">
        <div id="timer-text" style="position: absolute; top: 0; left: 8px; font-size: 40px">Tid tilbage:
            <strong><span id="timer" class="otree-timer__time-left"></span></strong>
        </div>
    </div>
    <script>
        $('#timer').on('DOMSubtreeModified', function () {
            let element = $('#timer');

            if (!element.hasClass('flash')) {
                let split = element.text().split(':');
                let minutes = parseInt(split[0]);
                let seconds = parseInt(split[1]);

                if (minutes <= 0 && seconds <= 20) {
                    $('#timer-text').addClass('flash');
                    element.addClass('flash')
                }
            }
        })
    </script>


    <style>
        .otree-timer {
            display: none
        }

        .otree-title {
            display: none
        }

        .info-div {
            display: flex;
            flex-direction: row;
            border-style: solid;
            border-width: thin;
            border-radius: 10px;
            padding: 1%;
            margin: 2%
        }

        .image-div {
            margin: 1%;
            flex: 1 1 0
        }

        .image-img {
            width: 90%;
            border-style: solid;
            border-width: thin;
            background: #f5f5f5
        }

        .guess-div {
            margin: 1%;
            flex: 1 1 0
        }

        tr {
            line-height: 20%
        }

        tr:nth-child(odd) {
            background: #CCC
        }

        tr:nth-child(even) {
            background: #FFF
        }

        .answer-container {
            display: flex;
            flex-direction: column;
            height: 10%;
            align-items: center;
            border-style: solid;
            border-width: thin;
            border-radius: 10px;
            padding: 1%;
            margin: 2%
        }

        ,
        .text-container {
            display: flex;
            flex-direction: column;
            height: 10%;
            align-items: center;
            border-style: solid;
            border-width: thin;
            border-radius: 10px;
            padding: 1%;
            margin: 2%
        }

        .answer-item {
            padding-left: 20px;
        }

        .text-item {
            padding-left: 20px;
        }
    </style>
    <div id="ButtonsHolder" class="choice-button-holder">
        <button id="GuessFalseButton" type="button" name="choice" value="False" class="btn choice-button">
            <img width="30px" height="30px" src="{{ question.majority_color_img }}"> {{ question.majority_choice }}
        </button>
        <button id="GuessTrueButton" type="button" name="choice" value="True" class="btn choice-button">
            <img width="30px" height="30px" src="{{ question.minority_color_img }}"> {{ question.minority_choice }}
        </button>
    </div>
    <script>
        // We want to randomise whether the button for the majority choice is on the left or the right
        // so that players can't catch on an tell which is the majority for the button position
        $('#ButtonsHolder').css('flex-direction', Math.random() > 0.5 ? 'row' : 'row-reverse')
    </script>

    {% comment %}
    {% for config in player.chat_configs %}
        <div class="answer-container" style="width: 100%;">
            <h4>{{ config.label }}</h4>
            {% chat nickname=player.chat_nickname channel=config.channel %}
        </div>
    {% endfor %}
    <style>
        .otree-chat__input {
            width: 100%;
        }
    </style>
    {% endcomment %}
    {% comment %}
    <div class="container">

        <h4 class="text-center">Chat med dine venner</h4>
        <div class="container d-flex justify-content-center flex-column col-6">
            <div class="chat-messages"></div>
            <div class="form-group">
                    <textarea id="chat-log" cols="100" rows="10"
                              class="form-control" disabled></textarea>
            </div>
            <div class="form-group">
                <input type="text" class="form-control" id="chat-message-input">

            </div>
            <input type="button" class="col-3 btn btn-success" id="chat-message-submit" value="Send"/>
        </div>
            </div>
        {% endcomment %}

    <div id="chat-container">
        <h2>Chat med dine venner</h2>
        <hr>
        <div class="form-group">
            <div id="chat" class="col-5"></div>
        </div>
        <div class="form-group">
            <input type="text" id="message" placeholder="Send besked..." class="form-control col-5">
        </div>
        <div class="form-group">
            <button id="send" class="btn btn-success">Send</button>
        </div>
    </div>

    <style>
        #chat {
            height: 250px;
            scroll-behavior: smooth;
            background: #ebeded;
            border-radius: 5px;
            padding: 15px;
            overflow: auto;
        }

        #chat::-webkit-scrollbar {
            width: 1em;
        }

        #chat::-webkit-scrollbar-track {
            -webkit-box-shadow: inset 0 0 6px rgba(0, 0, 0, 0.3);
        }

        #chat::-webkit-scrollbar-thumb {
            background-color: darkgrey;
            outline: 1px solid slategrey;
            border-radius: 10px;
        }

    .chat-message {
        display: flex;
    }

    .chat-message b {
        padding: 0 10px 0 0;
    }
    </style>


    <script>
        // Array container for the sent messages to be used in localstorage
        let messages = [];
        console.log("the type is a " + typeof localStorage.getItem('messages'));

        // Defines the scheme of the WebSocket to be either wss if the protocol is https
        // else it should be ws
        let ws_scheme = window.location.protocol === "https" ? "wss" : "ws";

        // Defines the WebSocket route to listen to
        let ws_path = ws_scheme + '://' + window.location.host + "/ws/chat/{{ group.pk }}";

        // Instantiates the WebSocket with the WebSocket route and scheme as argument
        let socket = new WebSocket(ws_path);

        // Defines the DOM element for the submit button
        const button = document.getElementById('send');

        // Function that adds the player id to each message
        const mapFriends = () => {
            let friends = {{ player.get_friends }};
            let players = [];

            friends.map(
                item => {
                    players.push(`player_${item}`)
                }
            )

            return players;
        };

        // Returns all the players friends in the network
        let players = mapFriends();

        // Variable used for displaying the right messages
        let network = [];

        // Opens the WebSocket connection and logs a message in the console when it opens
        socket.onopen = () => {
            console.log('WebSocket opened');
            console.log("{{ player.id }}");
            console.log("{{ player.id_in_group }}");
            /*
            const chat = document.getElementById('chat');
            let chat_messages = JSON.parse(localStorage.getItem('messages'));
            chat.innerHTML = chat_messages;
            */



        };

        // Closes the WebSocket connection and logs a message in the console when it closes
        socket.onclose = () => {
            console.log("WebSocket closed");
        }

        // Logs a error if the WebSocket gets a connection error in the console
        socket.onerror = event => {
            console.error("WebSocket error observed:", event);
        };

        // When a message is sent it is appended to the container with id of chat
        socket.onmessage = event => {
            let data = JSON.parse(event.data).message;
            let message = data.chat_message;
            let chat_id = data.player_id;
            let player_id = {{ player.id_in_group }};
            const chat = document.getElementById('chat');

            let divElement = document.createElement('div');
            let paragraphElement = document.createElement('p');
            let boldElement = document.createElement('b');
            divElement.appendChild(boldElement);
            divElement.appendChild(paragraphElement);

            divElement.setAttribute('class', 'chat-message');
            divElement.setAttribute('id', `player_${chat_id}`);

            if(chat_id === player_id) {
                boldElement.textContent = `Spiller ${chat_id} (Dig):`
            } else {
                boldElement.textContent = `Spiller ${chat_id}:`;
            }
            paragraphElement.textContent = message;
            chat.appendChild(divElement);
            displayFriends();

        };

        // Adds an event listener on the send button that submits the message
        // and sends it to the WebSocket inside a p tag with the Player id in the group
        // after the message is sent, the value of the input is reset.
        button.addEventListener("click", event => {
            event.preventDefault();

            let message = document.getElementById('message');



            if (message.value !== '') {
                socket.send(JSON.stringify({
                    'message': {
                        "chat_message": message.value,
                        "player_id": {{ player.id_in_group }}
                    }
                }));
            }

            message.value = '';

        });


        // Function that hides the messages outside of the players network
        const displayFriends = () => {

            let chat_class = document.getElementsByClassName('chat-message');

            for (let i = 0; i < chat_class.length; i++) {
                network.push(chat_class[i].getAttribute('id'));
            }

            for (let player in network) {
                if (players.includes(network[player])) {
                    document.getElementById(network[player]).style.display = 'flex';
                } else {
                    document.getElementById(network[player]).style.display = 'none';
                }
            }
        };

    </script>

{% endblock %}


{% block scripts %}
    {% include 'bad_influence/channels/network_voting_channel.html' %}
    {% include 'bad_influence/d3/d3_graph.html' %}
    {% if view.remaining_timeout_seconds != None %}
        {% include 'otree/includes/TimeLimit.js.html' %}
    {% endif %}
    {{ form.media|default:"" }}

{% endblock %}

{% block styles %}
    <style type="text/css">
        #cy {
            width: 100%;
            height: 600px;
            display: block;
        }
    </style>
{% endblock %}
