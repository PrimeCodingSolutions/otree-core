{% extends "global/Page.html" %}
{% load otree static %}
{% load static %}
{% block content %}
    <h2>{{ question.title }}</h2>
    <p>{{ question.text }}</p>
    <p>{{ question.preference }}</p>
    <p>{{ question.challenge }}</p>

    <style>
        .flash {
            animation-name: flash;
            animation-duration: 0.2s;
            animation-timing-function: linear;
            animation-iteration-count: infinite;
            animation-direction: alternate;
            animation-play-state: running;
        }

        @keyframes flash {
            from {
                color: red;
            }
            to {
                color: black;
            }
        }
    </style>



    <div style="display: flex; flex-direction: column; position: relative; min-height: 300px" class="answer-container"
         id="d3container">
        <div id="timer-text" style="position: absolute; top: 0; left: 8px; font-size: 40px">Tid tilbage:
            <strong><span id="timer" class="otree-timer__time-left"></span></strong>
        </div>
    </div>
    <script>
        $('#timer').on('DOMSubtreeModified', function () {
            let element = $('#timer');

            if (!element.hasClass('flash')) {
                let split = element.text().split(':');
                let minutes = parseInt(split[0]);
                let seconds = parseInt(split[1]);

                if (minutes <= 0 && seconds <= 20) {
                    $('#timer-text').addClass('flash');
                    element.addClass('flash')
                }
            }
        })
    </script>


    <style>
        .otree-timer {
            display: none
        }

        .otree-title {
            display: none
        }

        .info-div {
            display: flex;
            flex-direction: row;
            border-style: solid;
            border-width: thin;
            border-radius: 10px;
            padding: 1%;
            margin: 2%
        }

        .image-div {
            margin: 1%;
            flex: 1 1 0
        }

        .image-img {
            width: 90%;
            border-style: solid;
            border-width: thin;
            background: #f5f5f5
        }

        .guess-div {
            margin: 1%;
            flex: 1 1 0
        }

        tr {
            line-height: 20%
        }

        tr:nth-child(odd) {
            background: #CCC
        }

        tr:nth-child(even) {
            background: #FFF
        }

        .answer-container {
            display: flex;
            flex-direction: column;
            height: 10%;
            align-items: center;
            border-style: solid;
            border-width: thin;
            border-radius: 10px;
            padding: 1%;
            margin: 2%
        }

        ,
        .text-container {
            display: flex;
            flex-direction: column;
            height: 10%;
            align-items: center;
            border-style: solid;
            border-width: thin;
            border-radius: 10px;
            padding: 1%;
            margin: 2%
        }

        .answer-item {
            padding-left: 20px;
        }

        .text-item {
            padding-left: 20px;
        }
    </style>
    <div id="ButtonsHolder" class="choice-button-holder">
        <button id="GuessFalseButton" type="button" name="choice" value="False" class="btn choice-button">
            <img width="30px" height="30px" src="{{ question.majority_color_img }}"> {{ question.majority_choice }}
        </button>
        <button id="GuessTrueButton" type="button" name="choice" value="True" class="btn choice-button">
            <img width="30px" height="30px" src="{{ question.minority_color_img }}"> {{ question.minority_choice }}
        </button>
    </div>
    <script>
        // We want to randomise whether the button for the majority choice is on the left or the right
        // so that players can't catch on an tell which is the majority for the button position
        $('#ButtonsHolder').css('flex-direction', Math.random() > 0.5 ? 'row' : 'row-reverse')
    </script>

    {% comment %}
    {% for config in player.chat_configs %}
        <div class="answer-container" style="width: 100%;">
            <h4>{{ config.label }}</h4>
            {% chat nickname=player.chat_nickname channel=config.channel %}
        </div>
    {% endfor %}
    <style>
        .otree-chat__input {
            width: 100%;
        }
    </style>
    {% endcomment %}
    {% comment %}
    <div class="container">

        <h4 class="text-center">Chat med dine venner</h4>
        <div class="container d-flex justify-content-center flex-column col-6">
            <div class="chat-messages"></div>
            <div class="form-group">
                    <textarea id="chat-log" cols="100" rows="10"
                              class="form-control" disabled></textarea>
            </div>
            <div class="form-group">
                <input type="text" class="form-control" id="chat-message-input">

            </div>
            <input type="button" class="col-3 btn btn-success" id="chat-message-submit" value="Send"/>
        </div>
            </div>
        {% endcomment %}
    <div id="chat-container">
        <h2>Chat med dine venner</h2>
        <hr>
        <div class="form-group">
            <div id="chat" class="col-5"></div>
        </div>
        <div class="form-group">
            <input type="text" id="message" placeholder="Send besked..." class="form-control col-5">
        </div>
        <div class="form-group">
            <button id="send" class="btn btn-success">Send</button>
        </div>
    </div>
    {% comment %}
    <div class="chat-container">
        <div class="messages">
            <ul id="chat-log">

            </ul>
        </div>
        <div class="message-input">
            <div class="wrap">
                <input type="text" id="chat-message-input" placeholder="Skriv en besked...">
                <button id="chat-message-submit">Send</button>
            </div>
        </div>
    </div>
    {% endcomment %}
    <style>
        #chat {
            height: 250px;
            scroll-behavior: smooth;
            background: #ebeded;
            border-radius: 5px;
            padding: 15px;
            overflow: auto;
        }

        #chat::-webkit-scrollbar {
            width: 1em;
        }

        #chat::-webkit-scrollbar-track {
            -webkit-box-shadow: inset 0 0 6px rgba(0, 0, 0, 0.3);
        }

        #chat::-webkit-scrollbar-thumb {
            background-color: darkgrey;
            outline: 1px solid slategrey;
            border-radius: 10px;
        }

        .chat-message {
            display: flex;
        }

        .chat-message b {
            padding: 0 10px 0 0;
        }
    </style>

    <script>
        // Array container for the sent messages to be used in localstorage
        let messages = [];

        // Defines the scheme of the WebSocket to be either wss if the protocol is https
        // else it should be ws
        let ws_scheme = window.location.protocol === "https" ? "wss" : "ws";

        // Defines the WebSocket route to listen to
        let ws_path = ws_scheme + '://' + window.location.host + "/ws/chat/{{ group.pk }}";

        // Instantiates the WebSocket with the WebSocket route and scheme as argument
        let socket = new WebSocket(ws_path);

        // Defines the DOM element for the submit button
        const button = document.getElementById('send');

        // Function that adds the player id to each message
        const mapFriends = () => {
            let friends = {{ player.get_friends }};
            let players = [];

            friends.map(
                item => {
                    players.push(`player_${item}`)
                }
            )

            return players;
        };

        // Returns all the players friends in the network
        let players = mapFriends();

        // Variable used for displaying the right messages
        let network = [];

        let groups = [];

        // Opens the WebSocket connection and logs a message in the console when it opens
        socket.onopen = event => {
            console.log('WebSocket opened');
            fetchMessages();
        };

        // Closes the WebSocket connection and logs a message in the console when it closes
        socket.onclose = () => {
            console.log("WebSocket closed");
        }

        // Logs a error if the WebSocket gets a connection error in the console
        socket.onerror = event => {
            console.error("WebSocket error observed:", event);
        };

        // When a message is sent it is appended to the container with id of chat
        socket.onmessage = event => {
            let data = JSON.parse(event.data);
            if (data['command'] === 'messages') {
                for (let i = 0; i < data['messages'].length; i++) {
                    let data_player = "player_" + data['messages'][i]['chat_id'];
                    if (players.includes(data_player)) {
                        createMessage(data['messages'][i]);
                    }
                }
            } else if (data['command'] === 'new_message') {
                createMessage(data['message']);
            }

            console.log(data);
            {#if(data.group_id === {{ player.group_id }}) {#}
            {#    deleteMessages();#}
            {##}
        };

        // Adds an event listener on the send button that submits the message
        // and sends it to the WebSocket inside a p tag with the Player id in the group
        // after the message is sent, the value of the input is reset.
        document.querySelector("#message").onkeyup = function (e) {
            e.preventDefault();
            if (e.keyCode === 13) {
                document.querySelector("#send").click();
            }
        };

        document.querySelector("#send").onclick = function (e) {
            e.preventDefault();
            let messageInputDom = document.getElementById("message");
            let message = messageInputDom.value;
            if (message !== '') {
                socket.send(JSON.stringify({
                    'command': 'new_message',
                    'message': message,
                    'player_id': {{ player.id }},
                    'chat_id': {{ player.id_in_group }},
                    'group_id': {{ player.group_id }}
                }));
            }
            messageInputDom.value = '';
        };

        // Function that hides the messages outside of the players network
        const displayFriends = () => {

            let chat_class = document.getElementsByClassName('chat-message');

            for (let i = 0; i < chat_class.length; i++) {
                network.push(chat_class[i].getAttribute('id'));
            }

            for (let player in network) {
                if (players.includes(network[player])) {
                    document.getElementById(network[player]).style.display = 'flex';
                } else {
                    document.getElementById(network[player]).style.display = 'none';
                }
            }
        };

        function createMessage(data) {
            let divElement = document.createElement('div');
            let pElement = document.createElement('p');
            let bElement = document.createElement('b');

            pElement.textContent = data.content;
            if (data.chat_id === {{ player.id_in_group }}) {
                bElement.textContent = "Spiller " + data.chat_id + "(Dig):";
            } else {
                bElement.textContent = "Spiller " + data.chat_id + ":";
            }

            divElement.appendChild(bElement);
            divElement.appendChild(pElement);
            divElement.setAttribute('style', 'display: flex;')
            divElement.setAttribute('class', 'chat-message')
            divElement.setAttribute('id', `player_${data.chat_id}`)
            document.querySelector("#chat").appendChild(divElement);
            let chat_class = divElement;

            for (let i = 0; i < chat_class.length; i++) {
                network.push(chat_class[i].getAttribute('id'));
            }

            for (let player in network) {
                if (players.includes(network[player])) {
                    document.getElementById(network[player]).style.display = 'flex';
                } else {
                    document.getElementById(network[player]).style.display = 'none';
                }
            }
        }

        function fetchMessages() {
            socket.send(JSON.stringify({'command': 'fetch_messages'}))
        }

        function deleteMessages() {
            socket.send(JSON.stringify({'command': 'delete_messages'}))
        }

        displayFriends();

    </script>
    {% comment %}
    <script>
        let chatSocket = new ReconnectingWebSocket(
            'ws://' + window.location.host +
            '/test_chat/' + {{ group.pk }} + '/'
        );

        chatSocket.onopen = function (e) {
            fetchMessages();
        }

        chatSocket.onmessage = function (e) {
            let data = JSON.parse(e.data);
            if(data['command'] === 'messages') {
                for(let i = 0; i<data['messages'].length; i++) {
                    createMessage(data['message']);
                }
            } else if(data['command'] === 'new_message') {
                createMessage(data['message'])
            }
        };

        chatSocket.onclose = function (e) {
            console.error("Chat socket closed unexpectedly.");
        };

        document.querySelector("#chat-message-input").onkeyup = function (e) {
            e.preventDefault();
            if(e.keyCode === 13) {
                document.querySelector("#chat-message-submit").click();
            }
        };

        document.querySelector("#chat-message-submit").onclick = function (e) {
            e.preventDefault();
            let messageInputDom = document.getElementById('chat-message-input');
            let message = messageInputDom.value;
            chatSocket.send(JSON.stringify({
                'command': 'new_message',
                'message': message,
                'from': {{ player.id }}
            }));

            messageInputDom.value = '';
        };

        function fetchMessages() {
            chatSocket.send(JSON.stringify({'command': 'fetch_messages'}))
        }

        function createMessage(data) {
            let author = data['from'];
            let msgListTag = document.createElement('li');
            let pTag = document.createElement('p');
            pTag.textContent = data.content;

            if(author === {{ player.id }}) {
                msgListTag.className = 'sent';
            } else {
                msgListTag.className = 'replies';
            }

            msgListTag.appendChild(pTag);
            document.querySelector("#chat-log").appendChild(msgListTag);
        }
    </script>
    {% endcomment %}
{% endblock %}


{% block scripts %}
    {% include 'bad_influence/channels/network_voting_channel.html' %}
    {% include 'bad_influence/d3/d3_graph.html' %}
    {% if view.remaining_timeout_seconds != None %}
        {% include 'otree/includes/TimeLimit.js.html' %}
    {% endif %}
    {{ form.media|default:"" }}

{% endblock %}

{% block styles %}
    <style type="text/css">
        #cy {
            width: 100%;
            height: 600px;
            display: block;
        }
    </style>
{% endblock %}
